# LLM 流式输出场景下的 Mermaid 渲染优化专题文档

## 1. 问题背景
在 LLM (大语言模型) 的流式输出（Streaming）过程中，Mermaid 代码块是逐字符生成的。由于 Mermaid 渲染引擎需要完整的语法结构才能生成图表，中间态的代码往往是不完整的（例如缺少 `end`、括号未闭合等），这会导致渲染引擎频繁抛出红色错误提示，严重影响用户体验。

## 2. 优化策略与思路

### 2.1 延迟渲染策略 (Deferred Rendering)
*   **核心逻辑**：不渲染未闭合的代码块。
*   **实现方式**：在 Markdown 解析阶段，检测代码块的结束标记（如 ` ``` `）。只有当代码块完全闭合且流式输出结束时，才触发 Mermaid 渲染。
*   **优势**：彻底消除中间态报错，性能开销最小。

### 2.2 状态占位与骨架屏 (Skeleton Screens)
*   **核心逻辑**：在生成过程中提供视觉反馈，告知用户图表正在构建。
*   **实现方式**：在代码块区域显示一个带动画的骨架屏或“正在构思图表...”的提示语。
*   **优势**：缓解用户等待焦虑，保持界面美观。

### 2.3 错误捕获与静默处理 (Silent Error Handling)
*   **核心逻辑**：拦截渲染引擎的错误输出，不直接显示给用户。
*   **实现方式**：通过配置 Mermaid 的 `errorControls` 或拦截 `parseError` 回调，将错误信息重定向或隐藏。
*   **优势**：避免产品出现“崩溃”或“失败”的负面印象。

### 2.4 影子节点渲染 (Shadow Rendering)
*   **核心逻辑**：在后台不可见节点进行尝试性渲染。
*   **实现方式**：在内存或隐藏的 DOM 节点中进行渲染尝试。只有当渲染成功（返回有效的 SVG）时，才更新前端可见区域。
*   **优势**：实现图表的“平滑增长”，减少闪烁。

### 2.5 布局锁定与平滑过渡 (Anti-jitter & Smooth Transition)
*   **核心逻辑**：消除渲染状态切换时的视觉抖动。
*   **实现方式**：
    *   **高度预留**：为占位符设置最小高度（`min-height`），确保从“等待闭合”到“渲染中”容器尺寸稳定。
    *   **淡入动画**：在 SVG 渲染完成后，通过透明度过渡（Fade-in）平滑显示内容。
*   **优势**：消除页面内容跳动（Layout Shift），提供丝滑的视觉连贯性。

## 3. 主流应用处理方案

| 应用名称 | 主要处理方式 | 体验特点 |
| :--- | :--- | :--- |
| **ChatGPT / Claude** | 延迟渲染（闭合后渲染） | 生成时看代码逻辑，结束后展示精美图表，最稳健。 |
| **Notion AI** | 状态占位 + 平滑切换 | 明确的“加载中”提示，完成后淡入切换。 |
| **Mermaid Live Editor** | 去抖动（Debouncing）+ 实时尝试 | 极高的实时性，适合纯工具场景，但偶尔会有报错闪烁。 |

## 4. ROI (投入产出比) 分析

| 方案 | 开发成本 | 体验收益 | ROI 评价 | 建议 |
| :--- | :--- | :--- | :--- | :--- |
| **延迟至闭合渲染** | 极低 | 极高 | **极高** | 必须实现的基础方案。 |
| **布局高度锁定** | 低 | 高 | **极高** | 解决视觉抖动的关键细节。 |
| **错误捕获+友好占位** | 中低 | 高 | **高** | 提升专业感的进阶方案。 |
| **影子节点预渲染** | 高 | 中 | **低** | 仅在追求极致实时性时考虑。 |
| **自动补全增量渲染** | 极高 | 低 | **极低** | 不建议，维护成本巨大。 |

## 5. 结论与实施建议
对于大多数 AI 应用，建议采用 **“延迟渲染” + “错误静默” + “优雅占位”** 的组合方案：
1.  **第一步**：修改 Markdown 组件，在流式输出状态下，将 Mermaid 代码块渲染为纯文本形式。
2.  **第二步**：监听流式结束信号，在检测到代码块闭合后，启动 Mermaid 渲染引擎。
3.  **第三步**：在渲染过程中，显示自定义的 Loading 状态，并捕获可能的语法错误，确保 UI 不崩溃。
